# 性能提升60%：前端性能优化终极指南

---

**性能优化**一直是前端绕不开的话题。页面加载慢、交互卡顿，不仅影响用户体验，还可能直接流失用户。本文将从**加载、运行、构建、网络**四个环节，系统梳理前端能想到的各种性能优化手段，帮助我们尽可能的提升前端页面性能。

## 加载性能优化：更快呈现首屏

加载阶段的目标是**尽快把可见内容展示给用户**，减少白屏和首屏等待时间。

### 资源压缩与代码混淆

**资源压缩**的核心目标就是——**让浏览器传输和解析的文件尽可能小**，这样加载速度自然就快了。

- **代码压缩**：通过移除 HTML、CSS、JS 中的空格、注释，并缩短变量名来减小文件体积。打包阶段可借助 **Vite**、**Webpack** 等构建工具内置或插件化的压缩方案如 Terser 自动完成。
- **图片优化**：优先使用 `WebP` 或 **AVIF** 等高压缩比格式，并通过 **imagemin**、**tinypng** 等工具进一步压缩体积；对于大量小图标，可使用 `CSS Sprites` 合并成一张精灵图，减少 HTTP 请求数量。

### 代码分割（Code Splitting）

代码分割就是把项目代码按功能或页面拆成多个小文件，用户访问时**只加载当前需要的部分**，如路由懒加载：

**React**：

```js
import React, { Suspense } from 'react';
const Chart = React.lazy(() => import('./Chart'));

<Suspense fallback={<div>Loading...</div>}>
  <Chart />
</Suspense>
```

**Vue**：

```js
const routes = [
  { path: '/', component: () => import('@/views/Home.vue') },
  { path: '/about', component: () => import('@/views/About.vue') }
];
```

### Tree Shaking 摇树优化

**Tree Shaking** 是一种在打包阶段自动删除未使用代码的优化技术，能让最终文件更小、加载更快。它依赖 **ES Module** (`import`/`export`) 的静态结构来分析哪些代码实际被用到，没用到的就会被"摇掉"。

在 **Vite**（基于 Rollup）和大多数现代构建工具里，Tree Shaking 在**生产构建**时是默认开启的，只需要：

- 使用 ES Module 语法，而不是 `require`。
- 避免全局副作用代码，或在 `package.json` 中声明：

```json
{
  "sideEffects": false
}
```

### CDN 加速

**CDN 加速**就是把网站的静态资源（JS、CSS、图片、字体等）分发到全球多个节点，让用户就近从最近的服务器获取资源，从而减少网络延迟、提高加载速度。

项目中，可以将静态资源（JS、CSS、图片、字体）部署到阿里云或腾讯云等 CDN，让用户从最近的节点获取资源。

### 减少渲染阻塞

渲染阻塞是指浏览器在解析 HTML 时，遇到某些资源（如 CSS、同步 JS）会暂停页面渲染，直到这些资源加载并解析完成，这会直接延迟首屏显示时间。减少渲染阻塞的核心，就是让关键内容先呈现，非关键资源延后或异步加载。

- **CSS 优化**：将首屏必需的 CSS 抽取为关键 CSS 直接内联到 HTML，其余样式文件通过 `media` 属性或延迟加载方式引入。

```html
<link rel="stylesheet" href="style.css" media="print" onload="this.media='all'">
```

- **JS 优化**：对非首屏必须执行的 JS 使用 `defer` 或 `async`，避免阻塞 HTML 解析。

```html
<script src="app.js" defer></script>
<script src="analytics.js" async></script>
```

- **字体加载优化**：使用 `font-display: swap`，让文字在字体加载前先用系统字体渲染，避免长时间空白。

```css
@font-face {
  font-family: 'MyFont';
  src: url('myfont.woff2') format('woff2');
  font-display: swap;
}
```

### 预加载与预渲染

预加载与预渲染的目标是提前把可能需要的资源或页面准备好，让用户在点击或访问时几乎无等待。

- **preload**：提前加载关键资源（如字体、CSS、首屏图片），确保它们在渲染时已经准备就绪。

```html
<link rel="preload" href="/fonts/main.woff2" as="font" type="font/woff2" crossorigin>
```

- **prefetch**：利用浏览器空闲时间加载未来可能使用的资源（如下一页的 JS 文件），等真正用到时直接从缓存读取。

```html
<link rel="prefetch" href="/next-page.js">
```

### SSR 与 SSG

这两种方式都是在用户请求到达前，就把页面 HTML 准备好，从而减少白屏时间。

- **SSR（Server-Side Rendering）**：由服务端实时生成 HTML 并返回给浏览器，用户首屏几乎立刻可见，后续由前端接管交互。适合需要动态数据的场景，比如电商、资讯类网站。React 中我们可以借助 `next.js` 实现这一需求。
- **SSG（Static Site Generation）**：在构建阶段一次性生成所有静态 HTML 文件，用户访问时直接从服务器或 CDN 获取，速度极快且可离线访问。适合博客、文档类网站，Vue 中可以使用 `Nuxt.js` 实现。

### Gzip/Brotli 压缩

服务器在返回资源前进行压缩，浏览器接收后再解压，能显著减少传输体积。Gzip 和 Brotli 是两种常见的压缩算法，Brotli 压缩率更高，但需要服务器支持。

### 依赖共享

多个页面共享的依赖（如 React、Vue）可以提取到公共 bundle，利用浏览器缓存，避免重复下载。这在构建工具中通常会自动完成，你几乎不需要手动去配置。

## 运行阶段优化

### 避免不必要的重绘与回流

**重绘（Repaint）**：元素样式改变但不影响布局（如颜色、背景）。  
**回流（Reflow）**：元素尺寸、位置改变，需要重新计算布局。

优化建议：

- 批量修改 DOM，使用 `DocumentFragment` 或先 `display: none` 再修改
- 使用 `transform` 和 `opacity` 做动画（触发合成层，不触发回流）
- 避免频繁读取布局属性（如 `offsetWidth`），先读取后修改

```js
// ❌ 不好的做法
element.style.width = element.offsetWidth + 10 + 'px';
element.style.height = element.offsetHeight + 10 + 'px';

// ✅ 好的做法
const width = element.offsetWidth;
const height = element.offsetHeight;
element.style.width = width + 10 + 'px';
element.style.height = height + 10 + 'px';
```

### 虚拟滚动/列表

对于长列表，只渲染可见区域内的元素，减少 DOM 节点数量，提升滚动性能。

**React** 可以使用 `react-window` 或 `react-virtualized`：

```js
import { FixedSizeList } from 'react-window';

function VirtualList({ items }) {
  return (
    <FixedSizeList
      height={600}
      itemCount={items.length}
      itemSize={50}
      width="100%"
    >
      {({ index, style }) => (
        <div style={style}>{items[index]}</div>
      )}
    </FixedSizeList>
  );
}
```

**Vue** 可以使用 `vue-virtual-scroller`：

```vue
<template>
  <RecycleScroller
    class="scroller"
    :items="items"
    :item-size="50"
    key-field="id"
    v-slot="{ item }"
  >
    <div>{{ item.name }}</div>
  </RecycleScroller>
</template>
```

### 防抖与节流

**防抖（Debounce）**：事件触发后等待一段时间再执行，如果期间再次触发则重新计时。适合搜索框输入、窗口 resize。

```js
function debounce(fn, delay) {
  let timer = null;
  return function(...args) {
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

// 使用示例
const handleSearch = debounce((keyword) => {
  console.log('搜索:', keyword);
}, 300);
```

**节流（Throttle）**：事件触发后立即执行，但在指定时间内只执行一次。适合滚动事件、鼠标移动。

```js
function throttle(fn, delay) {
  let lastTime = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastTime >= delay) {
      fn.apply(this, args);
      lastTime = now;
    }
  };
}

// 使用示例
const handleScroll = throttle(() => {
  console.log('滚动中...');
}, 200);
```

**Vue 3 Composition API 示例**：

```vue
<script setup>
import { ref } from 'vue';

const timeoutId = ref(null);

function debounce(fn, delay) {
  return function(...args) {
    if (timeoutId.value) clearTimeout(timeoutId.value);
    timeoutId.value = setTimeout(() => {
      fn(...args);
    }, delay);
  };
}

function fetchData() {
  // 使用示例 API
  axios.get('http://api/example')
    .then(response => {
      console.log(response.data);
    });
}

const debouncedFetchData = debounce(fetchData, 300);
</script>
```

### 图片懒加载

只加载可视区域内的图片，减少初始加载时间。

**原生实现**：

```html
<img src="placeholder.jpg" data-src="real-image.jpg" loading="lazy" alt="图片">
```

**Intersection Observer API**：

```js
const images = document.querySelectorAll('img[data-src]');

const imageObserver = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const img = entry.target;
      img.src = img.dataset.src;
      img.removeAttribute('data-src');
      imageObserver.unobserve(img);
    }
  });
});

images.forEach(img => imageObserver.observe(img));
```

### Web Worker 分担计算压力

将耗时计算放到 Web Worker 中执行，避免阻塞主线程。

```js
// main.js
const worker = new Worker('worker.js');
worker.postMessage({ data: largeArray });
worker.onmessage = (e) => {
  console.log('计算结果:', e.data);
};

// worker.js
self.onmessage = (e) => {
  const result = e.data.data.map(item => item * 2);
  self.postMessage(result);
};
```

### 内存泄漏监控与优化

内存泄漏会让网页在长时间运行后越来越卡，最终崩溃。常见原因有：

- **未清理的事件监听器**
- **未清除的定时器**
- **闭包引用**
- **DOM 引用未释放**

**优化建议**：

```js
// Vue 3 Composition API
import { onMounted, onUnmounted } from 'vue';

onMounted(() => {
  window.addEventListener('resize', handleResize);
});

onUnmounted(() => {
  window.removeEventListener('resize', handleResize);
  // 清理定时器
  if (timer) clearInterval(timer);
});
```

## 构建优化

### 压缩与混淆

构建工具在生产环境会自动压缩和混淆代码，通常不需要手动配置。

### 第三方库优化

#### 分包策略

分包策略是指将打包后的代码分成多个 bundle，避免一次性加载所有资源，提高首屏速度。常见策略如**按路由分包**、**按组件分包**、**按依赖分包**。它能延迟非必要资源加载，提升首屏加载速度。

被分包的依赖，如第三方库，打包后 hash 值不变，重新部署会使用缓存文件，也能提升首屏加载速度。

在 Vite 中，使用它也很简单：

```js
// Vite Rollup 分包配置
export default {
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          react: ['react', 'react-dom'], // 单独打包 react
          lodash: ['lodash'] // lodash 单独打包
        }
      }
    }
  }
}
```

#### 懒加载第三方资源

这种方式类似路由懒加载，延迟非关键资源的下载，按需加载第三方库或模块，避免在初始加载时引入全部依赖，减轻首页负担。

```js
// React 动态导入
const Chart = React.lazy(() => import('./Chart'));

export default function Page() {
  return (
    <React.Suspense fallback={<div>Loading...</div>}>
      <Chart />
    </React.Suspense>
  );
}
```

#### 依赖排除

构建时将某些依赖排除，不打包进 bundle，而是从 CDN 加载。它可以有效减少 bundle 体积，利用缓存和边缘节点加速首页访问。

但并非依赖排除的越多越好，js 请求也需要网络。

如：

```js
// Vite 配置
export default {
  build: {
    rollupOptions: {
      external: ['vue'], // 排除 vue
    }
  }
}
```

## 网络优化

### TCP 预连接

提前与目标服务器建立 TCP + TLS 连接，减少请求延迟。

```html
<link rel="preconnect" href="https://cdn.example.com">
```

### DNS 预解析

提前解析域名，减少 DNS 查询延迟。

```html
<link rel="dns-prefetch" href="//cdn.example.com">
```

### 请求合并

对多个重复请求进行合并处理，前端可以通过防抖或判断接口状态实现。

```vue
<script setup>
import { ref } from 'vue';
import axios from 'axios';

const timeoutId = ref(null);

function debounce(fn, delay) {
  return function(...args) {
    if (timeoutId.value) clearTimeout(timeoutId.value);
    timeoutId.value = setTimeout(() => {
      fn(...args);
    }, delay);
  };
}

function fetchData() {
  axios.get('http://api/example')
    .then(response => {
      console.log(response.data);
    });
}

const debouncedFetchData = debounce(fetchData, 300);
</script>
```

## 如何查看网页性能

### 浏览器内置工具

#### 网络面板

查看网络请求，查看所有请求的耗时、大小、缓存命中情况，找出大文件、重复请求、慢响应资源。

#### 性能面板

- **FCP（First Contentful Paint，首次内容绘制时间）**：页面首次渲染内容的时间
- **LCP（Largest Contentful Paint，最大内容绘制时间）**：最大内容元素渲染完成的时间
- **CLS（Cumulative Layout Shift，累计布局偏移）**：页面布局稳定性指标
- **TTI（Time to Interactive，可交互时间）**：页面可交互的时间

#### Lighthouse 面板

自动化检测性能、可访问性、SEO 等综合评分，并给出优化建议。

### 第三方平台工具

#### WebPageTest

- URL：www.webpagetest.org/
- 模拟不同地区、网络条件下的页面加载，查看瀑布图、渲染时间线。

#### GTmetrix

- URL：gtmetrix.com/
- 类似 Lighthouse，但报告更细，可看首屏截图、视频回放，方便对比优化前后效果。

### 性能监控与上报

- **Sentry**：可采集性能、JS 错误、慢接口
- **阿里云 ARMS** / **字节火山监控**：支持前端 + 后端链路追踪
- **自建埋点系统**：结合 Performance API，将指标上报到日志系统

## 总结

本文梳理了一些比较常见的前端可行性能优化方案，有遗漏的地方，欢迎大家补充。

---

**参考资源**：

- [Web.dev 性能指南](https://web.dev/performance/)
- [MDN Web 性能](https://developer.mozilla.org/zh-CN/docs/Web/Performance)
- [Chrome DevTools 性能分析](https://developer.chrome.com/docs/devtools/performance/)

